<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Countdown</title>
  <meta name="description" content="Centered countdown with a smart photo wall that avoids the timer." />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='46' fill='%23000'/%3E%3Ctext x='50' y='62' font-size='56' text-anchor='middle' fill='%23fff'%3E%F0%9F%95%9B%EF%B8%8F%3C/text%3E%3C/svg%3E" />
  <style>
    :root{
      --text: #f4f7ff;
      --muted: #b8c0d6;
      --glass: rgba(10,12,18,.36);
      --ring: rgba(255,255,255,.28);
      --shadow: 0 20px 60px rgba(0,0,0,.55);
      --radius: 18px;
      --tile-gap: 6px;             /* space between tiles */
      --tile-target: 150px;        /* desired tile size (px), grid auto-calculates */
      --tile-radius: 10px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      color: var(--text);
      background: #0b0c10;
      overflow: hidden;
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
    }

    /* ===== PHOTO WALL LAYER ===== */
    .wall{
      position: fixed; inset: 0; z-index: 0;
      display: grid;
      gap: var(--tile-gap);
      padding: var(--tile-gap);
      background: #0b0c10;
    }
    .tile{
      background: #10131c;
      border-radius: var(--tile-radius);
      overflow: hidden;
      position: relative;
    }
    .tile img{
      position: absolute; inset: 0;
      width: 100%; height: 100%; object-fit: cover;
      transform: scale(1.04);
      transition: transform .3s ease, filter .3s ease, opacity .3s ease;
      opacity: .94;
      filter: saturate(1.05) contrast(1.02) brightness(.98);
    }
    .tile:hover img{ transform: scale(1.08); }

    /* Subtle vignette for legibility */
    .vignette{
      position: fixed; inset: 0; z-index: 1; pointer-events: none;
      background: radial-gradient(80% 60% at 50% 40%, rgba(0,0,0,.0) 0%, rgba(0,0,0,.55) 100%);
    }

    /* ===== FOREGROUND ===== */
    .wrap{
      position: relative; z-index: 2; height: 100%; width: 100%;
      display: grid; grid-template-rows: auto 1fr auto;
      place-items: center; padding: 20px; text-align: center;
    }

    header{
      width: 100%;
      display: grid; grid-template-columns: 1fr auto 1fr;
      align-items: center;
    }
    h1{
      grid-column: 2;
      margin: 0;
      font-weight: 800;
      letter-spacing: .4px;
      font-size: clamp(1.4rem, 1rem + 2.6vw, 3rem);
      text-shadow: 0 2px 16px rgba(0,0,0,.55);
      justify-self: center;
      pointer-events: none;
    }
    .controls{
      grid-column: 3; justify-self: end;
      display: flex; gap: 10px; align-items: center;
    }
    .btn{
      appearance: none; border: 1px solid rgba(255,255,255,.2);
      cursor: pointer; background: rgba(255,255,255,.12);
      color: var(--text); border-radius: 999px;
      padding: 8px 12px; font-weight: 700;
      backdrop-filter: blur(6px);
    }

    .timer-card{
      background: var(--glass);
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      border: 1px solid var(--ring);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: clamp(14px, 2vw, 22px);
      max-width: min(920px, 92vw);
      width: 100%;
      transition: all .25s ease;
    }
    .label{
      color: var(--muted);
      font-size: .95rem;
      margin-bottom: 8px;
    }
    .timer{
      display: grid;
      grid-template-columns: repeat(4, minmax(90px, 1fr));
      gap: clamp(8px, 2vw, 16px);
    }
    @media (max-width: 560px){
      .timer{ grid-template-columns: repeat(2, minmax(120px, 1fr)); }
    }
    .tbox{
      background: rgba(8,10,16,.55);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 14px;
      padding: clamp(12px, 2.2vw, 18px);
      text-align: center;
    }
    .num{
      font-variant-numeric: tabular-nums;
      font-weight: 900;
      font-size: clamp(2rem, 5.5vw, 3.2rem);
      line-height: 1.1; letter-spacing: .6px;
    }
    .lab{ margin-top: 6px; color: var(--muted); font-size: .95rem; }

    footer{ height: 1px; } /* no tip text */

    /* Fullscreen: move timer down so wall is unobstructed */
    .fs-active header{ display: none; }
    .fs-active .timer-card{
      position: fixed; left: 50%; bottom: 20px; transform: translateX(-50%);
      max-width: min(760px, 94vw);
      background: rgba(10,12,18,.28);
      border-color: rgba(255,255,255,.22);
    }
  </style>
</head>
<body>
  <!-- Smart photo wall -->
  <div class="wall" id="wall"></div>
  <div class="vignette" aria-hidden="true"></div>

  <!-- Foreground -->
  <div class="wrap">
    <header>
      <div></div>
      <h1>⏳ Guess whos back</h1>
      <div class="controls">
        <button class="btn" id="shuffleBtn" title="Shuffle photos">Shuffle</button>
        <button class="btn" id="fsBtn" title="Fullscreen">Fullscreen</button>
      </div>
    </header>

    <main class="timer-card" id="timerCard" aria-live="polite" aria-label="Countdown">
      <div class="label">Countdown to November 1, 2025 — 19:40</div>
      <div class="timer">
        <div class="tbox"><div class="num" id="days">00</div><div class="lab">Days</div></div>
        <div class="tbox"><div class="num" id="hours">00</div><div class="lab">Hours</div></div>
        <div class="tbox"><div class="num" id="mins">00</div><div class="lab">Minutes</div></div>
        <div class="tbox"><div class="num" id="secs">00</div><div class="lab">Seconds</div></div>
      </div>
    </main>

    <footer></footer>
  </div>

  <script>
    // ===== CONFIG =====
    const DEFAULT_TARGET = new Date("2025-11-01T19:40:00+03:00");
    const IMAGES = [
      { src: "images/IMG_20231224_192027.jpg", caption: "Photo 1" },
      { src: "images/IMG_20231224_192029.jpg", caption: "Photo 2" },
      // Add more images here if you like
    ];

    // ===== Countdown (locked) =====
    const pad = (n) => String(n).padStart(2, "0");
    let cdInterval = null;
    function startCountdown(targetDate){
      if (cdInterval) clearInterval(cdInterval);
      function tick(){
        const now = new Date();
        let diff = Math.max(0, targetDate - now);
        const d = Math.floor(diff / 86400000); diff -= d * 86400000;
        const h = Math.floor(diff / 3600000);  diff -= h * 3600000;
        const m = Math.floor(diff / 60000);    diff -= m * 60000;
        const s = Math.floor(diff / 1000);
        document.getElementById("days").textContent  = pad(d);
        document.getElementById("hours").textContent = pad(h);
        document.getElementById("mins").textContent  = pad(m);
        document.getElementById("secs").textContent  = pad(s);
      }
      tick();
      cdInterval = setInterval(tick, 1000);
    }
    startCountdown(DEFAULT_TARGET);

    // ===== Photo Wall logic =====
    const wall = document.getElementById("wall");
    const timerCard = document.getElementById("timerCard");
    const shuffleBtn = document.getElementById("shuffleBtn");
    const fsBtn = document.getElementById("fsBtn");

    // Preload images
    IMAGES.forEach(i => { const im = new Image(); im.src = i.src; });

    function shuffle(arr){
      for(let i = arr.length-1; i > 0; i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function buildWall(){
      // Figure out grid size based on target tile size
      const W = window.innerWidth;
      const H = window.innerHeight;
      const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--tile-gap")) || 6;
      const target = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--tile-target")) || 150;

      const cols = Math.max(3, Math.floor((W - gap) / (target + gap)));
      const rows = Math.max(3, Math.floor((H - gap) / (target + gap)));
      const cellW = (W - gap*(cols+1)) / cols;
      const cellH = (H - gap*(rows+1)) / rows;

      wall.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

      // Get exclusion zone (timer box) as grid cells
      const r = timerCard.getBoundingClientRect();
      const padCellsX = 1; // keep at least 1 cell margin around timer
      const padCellsY = 1;

      const startCol = Math.max(0, Math.floor((r.left - gap) / (cellW + gap)) - padCellsX);
      const endCol   = Math.min(cols-1, Math.floor((r.right - gap) / (cellW + gap)) + padCellsX);
      const startRow = Math.max(0, Math.floor((r.top - gap) / (cellH + gap)) - padCellsY);
      const endRow   = Math.min(rows-1, Math.floor((r.bottom - gap) / (cellH + gap)) + padCellsY);

      // Build list of available cells (row-major)
      const freeCells = [];
      for(let row=0; row<rows; row++){
        for(let col=0; col<cols; col++){
          const insideExclusion = (col >= startCol && col <= endCol && row >= startRow && row <= endRow);
          if(!insideExclusion) freeCells.push({row, col});
        }
      }

      // Randomly place up to IMAGES.length tiles in available cells
      wall.innerHTML = "";
      const order = shuffle([...IMAGES]); // randomize image order
      const cellsToUse = shuffle(freeCells).slice(0, order.length);

      // For nice packing "next to each other", take a compact cluster nearest to center
      // Sort chosen cells by distance to timer center to cluster them
      const timerCx = (r.left + r.right)/2;
      const timerCy = (r.top + r.bottom)/2;
      cellsToUse.sort((a,b)=>{
        const ax = (a.col + 0.5)*(cellW + gap) + gap;
        const ay = (a.row + 0.5)*(cellH + gap) + gap;
        const bx = (b.col + 0.5)*(cellW + gap) + gap;
        const by = (b.row + 0.5)*(cellH + gap) + gap;
        const da = Math.hypot(ax - timerCx, ay - timerCy);
        const db = Math.hypot(bx - timerCx, by - timerCy);
        return da - db;
      });

      // Create tiles
      for(let i=0; i<cellsToUse.length; i++){
        const {row, col} = cellsToUse[i];
        const tile = document.createElement("div");
        tile.className = "tile";
        tile.style.gridColumn = (col + 1);
        tile.style.gridRow = (row + 1);
        const img = document.createElement("img");
        img.src = order[i].src;
        img.alt = order[i].caption || `Photo ${i+1}`;
        img.loading = "lazy";
        img.decoding = "async";
        tile.appendChild(img);
        tile.addEventListener("click", ()=> {
          // Optional click behavior: bring this image to the front by reshuffling with it first
          const clicked = order[i];
          const rest = order.filter((_,k)=>k!==i);
          const newOrder = [clicked, ...shuffle(rest)];
          // Rebuild with same cells but new order
          wall.querySelectorAll(".tile img").forEach((im, idx)=>{
            if(newOrder[idx]) im.src = newOrder[idx].src;
          });
        });
        wall.appendChild(tile);
      }

      // Fill the CSS grid with empty cells so spacing aligns (optional)
      const used = new Set(cellsToUse.map(c=>`${c.row}:${c.col}`));
      const totalCells = rows*cols;
      // We only need placeholders if we want every cell in the grid to be a tile; but we prefer empty space.
      // So we skip adding placeholders to keep background visible.
    }

    // Initial build after first paint (so timer size is correct)
    window.addEventListener("load", ()=> {
      buildWall();
      // Rebuild on resize and on font load changes
      let t;
      window.addEventListener("resize", ()=>{ clearTimeout(t); t = setTimeout(buildWall, 120); });
    });

    // Rebuild when fullscreen toggles (timer moves, exclusion changes)
    document.addEventListener("fullscreenchange", ()=> {
      document.body.classList.toggle("fs-active", !!document.fullscreenElement);
      setTimeout(buildWall, 30);
    });

    // Controls
    shuffleBtn.addEventListener("click", buildWall);
    fsBtn.addEventListener("click", ()=>{
      if (!document.fullscreenElement) document.documentElement.requestFullscreen?.();
      else document.exitFullscreen?.();
    });
  </script>
</body>
</html>
