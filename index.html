<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Countdown</title>
  <meta name="description" content="Countdown with an evenly-spread rotating photo wall and full-screen slideshow." />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='46' fill='%23000'/%3E%3Ctext x='50' y='62' font-size='56' text-anchor='middle' fill='%23fff'%3E%F0%9F%95%9B%EF%B8%8F%3C/text%3E%3C/svg%3E" />
  <style>
    :root{
      --text:#f4f7ff; --muted:#b8c0d6; --glass:rgba(10,12,18,.36);
      --ring:rgba(255,255,255,.28); --shadow:0 20px 60px rgba(0,0,0,.55);
      --radius:18px;

      /* Photo wall tuning (desktop defaults) */
      --tile-gap:6px;
      --tile-target:150px;   /* desired tile size */
      --tile-radius:10px;
      --coverage:0.60;       /* ~60% of grid filled */
      --guard-cells:1;       /* safety ring around timer */
    }
    @media (max-width: 640px){
      :root{
        --tile-target:92px;
        --coverage:0.45;
        --guard-cells:0;
      }
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
      color:var(--text); background:#0b0c10; overflow:hidden;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }

    /* ===== Full-screen slideshow (visible only in fullscreen) ===== */
    .bg,.bg2{
      position:fixed; inset:0; z-index:0;
      background-position:center;
      background-repeat:no-repeat;
      background-size:contain;          /* FIT (no cropping) */
      background-color:#000;
      filter:brightness(.88) saturate(1.02);
      transition:opacity 1.1s ease;
      display:none;
    }
    .bg{opacity:1}
    .bg2{opacity:0}
    .fs-active .bg, .fs-active .bg2{display:block}

    /* ===== Photo Wall (hidden in fullscreen) ===== */
    .wall{position:fixed; inset:0; z-index:0; display:grid; gap:var(--tile-gap); padding:var(--tile-gap); background:#0b0c10}
    .fs-active .wall{display:none}
    .tile{background:#10131c; border-radius:var(--tile-radius); overflow:hidden; position:relative}
    .tile img{
      position:absolute; inset:0; width:100%; height:100%; object-fit:cover;
      transform:scale(1.04);
      transition:transform .25s ease, opacity .35s ease, filter .25s ease;
      opacity:.96; filter:saturate(1.05) contrast(1.02) brightness(.98)
    }
    .tile:hover img{transform:scale(1.08)}

    .vignette{position:fixed; inset:0; z-index:1; pointer-events:none; background:radial-gradient(80% 60% at 50% 40%, rgba(0,0,0,.0) 0%, rgba(0,0,0,.55) 100%)}

    /* ===== Foreground (header + timer) ===== */
    .wrap{position:relative; z-index:2; height:100%; width:100%; display:grid; grid-template-rows:auto 1fr auto; place-items:center; padding:20px; text-align:center}
    header{width:100%; display:grid; grid-template-columns:1fr auto 1fr; align-items:center}
    h1{grid-column:2; margin:0; font-weight:800; letter-spacing:.4px; font-size:clamp(1.4rem,1rem + 2.6vw,3rem); text-shadow:0 2px 16px rgba(0,0,0,.55); justify-self:center; pointer-events:none}
    .controls{grid-column:3; justify-self:end; display:flex; gap:10px; align-items:center}
    .btn{appearance:none; border:1px solid rgba(255,255,255,.2); cursor:pointer; background:rgba(255,255,255,.12); color:var(--text); border-radius:999px; padding:8px 12px; font-weight:700; backdrop-filter:blur(6px)}

    .timer-card{background:var(--glass); -webkit-backdrop-filter:blur(10px); backdrop-filter:blur(10px); border:1px solid var(--ring); border-radius:var(--radius); box-shadow:var(--shadow); padding:clamp(14px,2vw,22px); max-width:min(920px,92vw); width:100%; transition:all .25s ease}
    .label{color:var(--muted); font-size:.95rem; margin-bottom:8px}
    .timer{display:grid; grid-template-columns:repeat(4, minmax(90px, 1fr)); gap:clamp(8px,2vw,16px)}
    @media (max-width:560px){.timer{grid-template-columns:repeat(2, minmax(120px, 1fr))}}
    .tbox{background:rgba(8,10,16,.55); border:1px solid rgba(255,255,255,.18); border-radius:14px; padding:clamp(12px,2.2vw,18px); text-align:center}
    .num{font-variant-numeric:tabular-nums; font-weight:900; font-size:clamp(2rem,5.5vw,3.2rem); line-height:1.1; letter-spacing:.6px}
    .lab{margin-top:6px; color:var(--muted); font-size:.95rem}
    footer{height:1px}

    /* Fullscreen: move timer down */
    .fs-active header{display:none}
    .fs-active .timer-card{
      position:fixed; left:50%; bottom:20px; transform:translateX(-50%);
      max-width:min(760px,94vw); background:rgba(10,12,18,.28); border-color:rgba(255,255,255,.22)
    }
  </style>
</head>
<body>
  <!-- Full-screen slideshow layers -->
  <div class="bg" id="bg1" role="img" aria-label="Background photo"></div>
  <div class="bg2" id="bg2" role="img" aria-label="Background photo (next)"></div>

  <!-- Photo wall (normal mode) -->
  <div class="wall" id="wall"></div>

  <div class="vignette" aria-hidden="true"></div>

  <!-- Foreground -->
  <div class="wrap">
    <header>
      <div></div>
      <h1>⏳ Guess whos back</h1>
      <div class="controls">
        <button class="btn" id="shuffleBtn" title="Rebuild wall">Shuffle</button>
        <button class="btn" id="fsBtn" title="Fullscreen">Fullscreen</button>
      </div>
    </header>

    <main class="timer-card" id="timerCard" aria-live="polite" aria-label="Countdown">
      <div class="label">Countdown to November 1, 2025 — 19:40</div>
      <div class="timer">
        <div class="tbox"><div class="num" id="days">00</div><div class="lab">Days</div></div>
        <div class="tbox"><div class="num" id="hours">00</div><div class="lab">Hours</div></div>
        <div class="tbox"><div class="num" id="mins">00</div><div class="lab">Minutes</div></div>
        <div class="tbox"><div class="num" id="secs">00</div><div class="lab">Seconds</div></div>
      </div>
    </main>

    <footer></footer>
  </div>

  <script>
    // ===== CONFIG =====
    const DEFAULT_TARGET = new Date("2025-11-01T19:40:00+03:00");
    // Rotating wall settings
    const ROTATE_MS = 6000;       // how often to rotate some tiles
    const ROTATE_BATCH = 3;       // how many tiles swap per tick
    const PAUSE_ON_HOVER = true;  // don't swap a tile if it's hovered

    const IMAGES = [
      { src: "images/IMG_20161229_204822.jpg", caption: "IMG_20161229_204822" },
      { src: "images/IMG_20170709_123029.jpg", caption: "IMG_20170709_123029" },
      { src: "images/IMG_20180818_215728.jpg", caption: "IMG_20180818_215728" },
      { src: "images/IMG_20190714_222629.jpg", caption: "IMG_20190714_222629" },
      { src: "images/IMG_20200517_230350.jpg", caption: "IMG_20200517_230350" },
      { src: "images/IMG_20200517_230712.jpg", caption: "IMG_20200517_230712" },
      { src: "images/IMG_20200911_195128.jpg", caption: "IMG_20200911_195128" },
      { src: "images/IMG_20200920_235009.jpg", caption: "IMG_20200920_235009" },
      { src: "images/IMG_20211103_135906.jpg", caption: "IMG_20211103_135906" },
      { src: "images/IMG_20211229_140745.jpg", caption: "IMG_20211229_140745" },
      { src: "images/IMG_20220304_185250.jpg", caption: "IMG_20220304_185250" },
      { src: "images/IMG_20220306_014832.jpg", caption: "IMG_20220306_014832" },
      { src: "images/IMG_20220918_112717.jpg", caption: "IMG_20220918_112717" },
      { src: "images/IMG_20231224_192027.jpg", caption: "IMG_20231224_192027" },
      { src: "images/IMG_20231224_192029.jpg", caption: "IMG_20231224_192029" },
      { src: "images/IMG_20231224_193639.jpg", caption: "IMG_20231224_193639" },
      { src: "images/IMG_20240801_150855.jpg", caption: "IMG_20240801_150855" },
      { src: "images/IMG_20250518_014704004_HDR.jpg", caption: "IMG_20250518_014704004_HDR" },
      { src: "images/IMG_20250712_170059692_HDR.jpg", caption: "IMG_20250712_170059692_HDR" },
    ];

    // ===== Countdown =====
    const pad = n => String(n).padStart(2,"0");
    let cdInterval=null;
    function startCountdown(targetDate){
      if(cdInterval) clearInterval(cdInterval);
      function tick(){
        const now=new Date(); let diff=Math.max(0,targetDate-now);
        const d=Math.floor(diff/86400000); diff-=d*86400000;
        const h=Math.floor(diff/3600000);  diff-=h*3600000;
        const m=Math.floor(diff/60000);    diff-=m*60000;
        const s=Math.floor(diff/1000);
        days.textContent=pad(d); hours.textContent=pad(h); mins.textContent=pad(m); secs.textContent=pad(s);
      }
      const days=document.getElementById("days"), hours=document.getElementById("hours"),
            mins=document.getElementById("mins"), secs=document.getElementById("secs");
      tick(); cdInterval=setInterval(tick,1000);
    }
    startCountdown(DEFAULT_TARGET);

    // ===== Elements
    const wall=document.getElementById("wall");
    const timerCard=document.getElementById("timerCard");
    const shuffleBtn=document.getElementById("shuffleBtn");
    const fsBtn=document.getElementById("fsBtn");
    const bg1=document.getElementById("bg1");
    const bg2=document.getElementById("bg2");

    // Preload (optional; browser will cache as they load during rotation)
    IMAGES.forEach(i=>{const im=new Image(); im.src=i.src;});

    // --- Blue-noise cell picking (even spread)
    function pickEvenlySpacedCells(freeCells, desired, cols, rows){
      if(!freeCells.length||desired<=0) return [];
      const cx=(cols-1)/2, cy=(rows-1)/2;
      let seed=freeCells[0], best=-1;
      for(const c of freeCells){ const dx=c.col-cx, dy=c.row-cy, s=dx*dx+dy*dy; if(s>best){best=s; seed=c;} }
      const selected=[seed];
      while(selected.length<desired && selected.length<freeCells.length){
        let bestCell=null, bestDist=-1;
        for(const c of freeCells){
          if(selected.some(s=>s.col===c.col && s.row===c.row)) continue;
          let minD2=Infinity;
          for(const s of selected){ const dx=c.col-s.col, dy=c.row-s.row, d2=dx*dx+dy*dy; if(d2<minD2) minD2=d2; }
          if(minD2>bestDist){ bestDist=minD2; bestCell=c; }
        }
        if(!bestCell) break; selected.push(bestCell);
      }
      return selected;
    }
    function shuffleInPlace(a){ for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

    // ===== Photo Wall (with rotation) =====
    let tiles = [];                    // [{ el, imgEl, imgIndex }]
    let visibleSet = new Set();        // image indexes currently on screen
    let pool = [];                     // image indexes available to rotate in
    let rotateTimer = null;
    const lastSwapAt = new Map();      // tile -> timestamp to avoid rapid re-swap

    function computeFreeCells(cols, rows, gap, cellW, cellH, guard){
      const r=timerCard.getBoundingClientRect();
      const startCol=Math.max(0,Math.floor((r.left-gap)/(cellW+gap))-guard);
      const endCol=Math.min(cols-1,Math.floor((r.right-gap)/(cellW+gap))+guard);
      const startRow=Math.max(0,Math.floor((r.top-gap)/(cellH+gap))-guard);
      const endRow=Math.min(rows-1,Math.floor((r.bottom-gap)/(cellH+gap))+guard);
      const free=[];
      for(let row=0; row<rows; row++){
        for(let col=0; col<cols; col++){
          const inside=(col>=startCol && col<=endCol && row>=startRow && row<=endRow);
          if(!inside) free.push({row,col});
        }
      }
      return free;
    }

    function stopWallRotation(){
      if(rotateTimer){ clearInterval(rotateTimer); rotateTimer=null; }
    }

    function startWallRotation(){
      stopWallRotation();
      if(pool.length === 0) return; // nothing to rotate in
      rotateTimer = setInterval(rotateSomeTiles, ROTATE_MS);
    }

    function rotateSomeTiles(){
      if(pool.length === 0 || tiles.length === 0) return;

      const now = performance.now();
      // Build a candidate list of tile indices we can swap
      const candidates = tiles
        .map((t, i) => ({t, i}))
        .filter(({t})=>{
          if(PAUSE_ON_HOVER && t.el.matches(':hover')) return false;
          const last = lastSwapAt.get(t.el) || 0;
          return (now - last) > ROTATE_MS * 1.2; // cool-down
        });

      if(candidates.length === 0) return;

      shuffleInPlace(candidates);
      const swaps = Math.min(ROTATE_BATCH, candidates.length, pool.length);
      for(let k=0; k<swaps; k++){
        const {t, i: tileIndex} = candidates[k];
        // Take next new image that's not currently visible
        // (pool should already contain non-visible, but guard just in case)
        let nextIdx = pool.shift();
        if(nextIdx == null) break;
        if(visibleSet.has(nextIdx)){
          // find a truly non-visible one
          let found = -1;
          for(let j=0;j<pool.length;j++){
            if(!visibleSet.has(pool[j])){ found = j; break; }
          }
          if(found >= 0){
            // put back the duplicate and take the found one
            pool.push(nextIdx);
            nextIdx = pool.splice(found, 1)[0];
          }else{
            // fallback: use it anyway
          }
        }

        // Move the old one back into the pool tail
        if(Number.isInteger(t.imgIndex)){
          visibleSet.delete(t.imgIndex);
          pool.push(t.imgIndex);
        }
        // Apply new image with a tiny fade
        t.imgEl.style.opacity = 0;
        const newImg = IMAGES[nextIdx];
        setTimeout(()=>{
          t.imgEl.src = newImg.src;
          t.imgEl.alt = newImg.caption || "Photo";
          t.imgEl.onload = ()=>{ t.imgEl.style.opacity = .96; };
        }, 150);

        t.imgIndex = nextIdx;
        visibleSet.add(nextIdx);
        lastSwapAt.set(t.el, now);
      }
    }

    function buildWall(){
      // grid sizing
      const W=innerWidth, H=innerHeight, cs=getComputedStyle(document.documentElement);
      const gap=parseFloat(cs.getPropertyValue("--tile-gap"))||6;
      const target=parseFloat(cs.getPropertyValue("--tile-target"))||150;
      const coverageBase=Math.max(0,Math.min(1,parseFloat(cs.getPropertyValue("--coverage"))||0.6));
      const guardBase=parseInt(cs.getPropertyValue("--guard-cells"))||0;

      const cols=Math.max(2,Math.floor((W-gap)/(target+gap)));
      const rows=Math.max(2,Math.floor((H-gap)/(target+gap)));
      const cellW=(W-gap*(cols+1))/cols, cellH=(H-gap*(rows+1))/rows;
      wall.style.gridTemplateColumns=`repeat(${cols},1fr)`;

      // exclusion
      let guard=guardBase;
      let free=computeFreeCells(cols,rows,gap,cellW,cellH,guard);
      if(free.length===0){
        guard=0;
        free=computeFreeCells(cols,rows,gap,cellW,cellH,guard);
        if(free.length===0){ for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) free.push({row:r,col:c}); }
      }

      const total=rows*cols;
      const relaxed = (guard!==guardBase);
      const coverage = relaxed ? Math.min(coverageBase, 0.40) : coverageBase;
      const desired=Math.min(free.length, Math.max(1, Math.round(total*coverage)));

      // pick cells evenly spread
      const cells=pickEvenlySpacedCells(free, desired, cols, rows);

      // initial image assignment:
      // make a shuffled list of all image indices
      const allIdx = [...IMAGES.keys()];
      shuffleInPlace(allIdx);

      visibleSet.clear();
      tiles = [];
      wall.innerHTML="";
      lastSwapAt.clear();

      // If we have fewer images than desired tiles, we'll repeat later via rotation pool being empty.
      const initial = allIdx.slice(0, Math.min(desired, allIdx.length));
      // pool is whatever remains
      pool = allIdx.slice(initial.length);

      // If images < desired, fill the rest by repeating initial (still okay; rotation will be idle)
      while(initial.length < desired){
        initial.push(...allIdx);
      }

      for(let i=0;i<cells.length;i++){
        const {row,col}=cells[i];
        const idx = initial[i % initial.length]; // safe
        const t=document.createElement("div"); t.className="tile";
        t.style.gridColumn=(col+1); t.style.gridRow=(row+1);
        const img=document.createElement("img");
        img.src=IMAGES[idx].src; img.alt=IMAGES[idx].caption||`Photo ${i+1}`;
        img.loading="lazy"; img.decoding="async";
        t.appendChild(img); wall.appendChild(t);
        tiles.push({ el: t, imgEl: img, imgIndex: idx });
        visibleSet.add(idx);
      }

      // Remove any visible ones from pool just in case
      pool = pool.filter(id => !visibleSet.has(id));

      // kick off rotation
      startWallRotation();
    }

    // Rebuild wall on resize / shuffle
    let resizeT; function rebuildWallSoon(){ clearTimeout(resizeT); resizeT=setTimeout(buildWall,120); }
    addEventListener("load", buildWall);
    addEventListener("resize", ()=>{ stopWallRotation(); rebuildWallSoon(); });
    shuffleBtn.addEventListener("click", ()=>{ stopWallRotation(); buildWall(); });

    // ===== Fullscreen slideshow (FIT, random order each time) =====
    let slideIdx=0, onFirst=true, autoTimer=null; const AUTO_MS=6000;
    function setBG(div, i){
      const it=IMAGES[(i+IMAGES.length)%IMAGES.length];
      div.style.backgroundImage=`url('${it.src}')`;
      div.setAttribute("aria-label", it.caption||"Background photo");
    }
    function showNext(){
      const next=(slideIdx+1)%IMAGES.length;
      if(onFirst){ setBG(bg2,next); bg2.style.opacity=1; bg1.style.opacity=0; }
      else       { setBG(bg1,next); bg1.style.opacity=1; bg2.style.opacity=0; }
      onFirst=!onFirst; slideIdx=next;
    }
    function startSlideshow(){
      if(!IMAGES.length) return;
      shuffleInPlace(IMAGES);      // randomize order on each enter
      setBG(bg1,0);
      if(autoTimer) clearInterval(autoTimer);
      autoTimer=setInterval(showNext,AUTO_MS);
    }
    function restartAuto(){ if(autoTimer){ clearInterval(autoTimer); autoTimer=setInterval(showNext,AUTO_MS);} }
    addEventListener("keydown", e=>{
      if(!document.fullscreenElement) return;
      if(e.key==="ArrowRight"){ showNext(); restartAuto(); }
      if(e.key==="ArrowLeft"){
        const prev=(slideIdx-1+IMAGES.length)%IMAGES.length;
        if(onFirst){ setBG(bg2,prev); bg2.style.opacity=1; bg1.style.opacity=0; }
        else       { setBG(bg1,prev); bg1.style.opacity=1; bg2.style.opacity=0; }
        onFirst=!onFirst; slideIdx=prev; restartAuto();
      }
    });

    // Fullscreen toggle
    fsBtn.addEventListener("click", ()=>{
      if(!document.fullscreenElement) document.documentElement.requestFullscreen?.();
      else document.exitFullscreen?.();
    });
    document.addEventListener("fullscreenchange", ()=>{
      const fs=!!document.fullscreenElement;
      document.body.classList.toggle("fs-active", fs);
      if(fs){
        // Pause wall swaps to save work
        stopWallRotation();
        startSlideshow();
      } else {
        if(autoTimer) clearInterval(autoTimer);
        // Timer returns to center; rebuild wall & resume rotation
        setTimeout(buildWall, 30);
      }
    });
  </script>
</body>
</html>
