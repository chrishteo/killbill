<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Countdown</title>
  <meta name="description" content="Countdown with an evenly-spread rotating photo wall, full-screen slideshow, and a one-time intro." />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='46' fill='%23000'/%3E%3Ctext x='50' y='62' font-size='56' text-anchor='middle' fill='%23fff'%3E%F0%9F%95%9B%EF%B8%8F%3C/text%3E%3C/svg%3E" />
  <style>
    :root{
      --text:#f4f7ff; --muted:#b8c0d6; --glass:rgba(10,12,18,.36);
      --ring:rgba(255,255,255,.28); --shadow:0 20px 60px rgba(0,0,0,.55);
      --radius:18px;

      /* Photo wall tuning (desktop defaults) */
      --tile-gap:6px;
      --tile-target:150px;   /* desired tile size */
      --tile-radius:10px;
      --coverage:1.00;       /* fraction of grid filled (1.0 = all free cells) */
      --guard-cells:0;       /* safety ring around timer */
    }
    @media (max-width: 640px){
      :root{
        --tile-gap:4px;
        --tile-target:92px;
        --coverage:1.00;
        --guard-cells:0;
      }
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
      color:var(--text); background:#0b0c10; overflow:hidden;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }

    /* ===== Full-screen slideshow (visible only in fullscreen) ===== */
    .bg,.bg2{
      position:fixed; inset:0; z-index:0;
      background-position:center;
      background-repeat:no-repeat;
      background-size:contain;          /* FIT (no cropping) */
      background-color:#000;
      filter:brightness(.88) saturate(1.02);
      transition:opacity 1.1s ease;
      display:none;
    }
    .bg{opacity:1}
    .bg2{opacity:0}
    .fs-active .bg, .fs-active .bg2{display:block}

    /* ===== Photo Wall (hidden in fullscreen) ===== */
    .wall{position:fixed; inset:0; z-index:0; display:grid; gap:var(--tile-gap); padding:var(--tile-gap); background:#0b0c10}
    .fs-active .wall{display:none}
    .tile{background:#10131c; border-radius:var(--tile-radius); overflow:hidden; position:relative; contain: paint;}
    .tile img{
      position:absolute; inset:0; width:100%; height:100%; object-fit:cover;
      transform:scale(1.04);
      transition:transform .25s ease, opacity .35s ease, filter .25s ease;
      opacity:.96; filter:saturate(1.05) contrast(1.02) brightness(.98);
      will-change: opacity, transform;
    }
    .tile:hover img{transform:scale(1.08)}

    .vignette{position:fixed; inset:0; z-index:1; pointer-events:none; background:radial-gradient(80% 60% at 50% 40%, rgba(0,0,0,.0) 0%, rgba(0,0,0,.55) 100%)}

    /* ===== Foreground (header + timer) ===== */
    .wrap{position:relative; z-index:2; height:100%; width:100%; display:grid; grid-template-rows:auto 1fr auto; place-items:center; padding:20px; text-align:center}
    header{width:100%; display:grid; grid-template-columns:1fr auto 1fr; align-items:center}
    h1{grid-column:2; margin:0; font-weight:800; letter-spacing:.4px; font-size:clamp(1.4rem,1rem + 2.6vw,3rem); text-shadow:0 2px 16px rgba(0,0,0,.55); justify-self:center; pointer-events:none}
    .controls{grid-column:3; justify-self:end; display:flex; gap:10px; align-items:center}
    .btn{appearance:none; border:1px solid rgba(255,255,255,.2); cursor:pointer; background:rgba(255,255,255,.12); color:var(--text); border-radius:999px; padding:8px 12px; font-weight:700; backdrop-filter:blur(6px)}

    .timer-card{background:var(--glass); -webkit-backdrop-filter:blur(10px); backdrop-filter:blur(10px); border:1px solid var(--ring); border-radius:var(--radius); box-shadow:var(--shadow); padding:clamp(14px,2vw,22px); max-width:min(920px,92vw); width:100%; transition:all .25s ease}
    .label{color:var(--muted); font-size:.95rem; margin-bottom:8px}
    .timer{display:grid; grid-template-columns:repeat(4, minmax(90px, 1fr)); gap:clamp(8px,2vw,16px)}
    @media (max-width:560px){.timer{grid-template-columns:repeat(2, minmax(120px, 1fr))}}
    .tbox{background:rgba(8,10,16,.55); border:1px solid rgba(255,255,255,.18); border-radius:14px; padding:clamp(12px,2.2vw,18px); text-align:center}
    .num{font-variant-numeric:tabular-nums; font-weight:900; font-size:clamp(2rem,5.5vw,3.2rem); line-height:1.1; letter-spacing:.6px}
    .lab{margin-top:6px; color:var(--muted); font-size:.95rem}
    footer{height:1px}

    /* Fullscreen: move timer down */
    .fs-active header{display:none}
    .fs-active .timer-card{
      position:fixed; left:50%; bottom:20px; transform:translateX(-50%);
      max-width:min(760px,94vw); background:rgba(10,12,18,.28); border-color:rgba(255,255,255,.22)
    }

    /* ===== Intro overlay ===== */
    .intro{
      position:fixed; inset:0; z-index:9999; display:grid; place-items:center;
      background:
        radial-gradient(1200px 800px at 80% -10%, #1a1f2c 0%, #0b0c10 60%),
        #0b0c10;
      overflow:hidden;
      color:#eaf0ff;
      opacity:1;
      transition:opacity .6s ease, visibility .6s ease;
      visibility:visible;
    }
    .intro.hide{ opacity:0; visibility:hidden; }

    .intro-head{
      position:relative; text-align:center; z-index:2;
      transform:translateY(10px); opacity:0; animation:introIn .8s .2s ease forwards;
    }
    .intro-title{
      font-weight:900; letter-spacing:.6px;
      font-size:clamp(1.8rem, 2.2vw + 1.3rem, 3.2rem);
      text-shadow:0 6px 40px rgba(0,0,0,.7);
    }
    .intro-sub{ margin-top:8px; color:var(--muted); font-size:clamp(.95rem, .4vw + .85rem, 1.1rem); }

    @keyframes introIn{
      from{ transform:translateY(16px); opacity:0; filter:blur(6px); }
      to{ transform:translateY(0); opacity:1; filter:blur(0); }
    }

    .intro-tiles{
      position:absolute; inset:-10% -10% -10% -10%; z-index:1; pointer-events:none;
      filter:blur(.2px);
    }
    .intro-tile{
      position:absolute; width:16vmin; height:10vmin; border-radius:12px;
      background:linear-gradient(180deg, #1b2030, #121620); border:1px solid rgba(255,255,255,.06);
      box-shadow:0 10px 40px rgba(0,0,0,.35);
      opacity:0; transform:translateY(12vh) scale(.98) rotate(var(--rot, 0deg));
      animation: rise var(--dur, 1800ms) var(--delay, 0ms) cubic-bezier(.22,.61,.36,1) forwards;
    }
    .intro-tile::after{
      content:""; position:absolute; inset:0;
      background:radial-gradient(100% 100% at 50% 0%, rgba(255,255,255,.08), rgba(0,0,0,0));
    }
    @keyframes rise{
      0%{ opacity:0; transform:translateY(12vh) scale(.98) rotate(var(--rot, 0deg)); }
      60%{ opacity:.9; }
      100%{ opacity:0; transform:translateY(-18vh) scale(1) rotate(calc(var(--rot, 0deg) + 6deg)); }
    }

    .intro-skip{
      position:fixed; right:14px; bottom:14px; z-index:3;
      background:rgba(255,255,255,.12); color:#eaf0ff; border:1px solid rgba(255,255,255,.22);
      border-radius:999px; padding:8px 12px; font-weight:700; cursor:pointer;
      backdrop-filter:blur(6px);
      transition:transform .08s ease, opacity .2s ease;
    }
    .intro-skip:active{ transform:translateY(1px); }

    @media (prefers-reduced-motion: reduce){
      .intro-tiles{display:none;}
      .intro-head{animation:none; opacity:1; transform:none;}
    }
  </style>
</head>
<body>
  <!-- Full-screen slideshow layers -->
  <div class="bg" id="bg1" role="img" aria-label="Background photo"></div>
  <div class="bg2" id="bg2" role="img" aria-label="Background photo (next)"></div>

  <!-- Photo wall (normal mode) -->
  <div class="wall" id="wall"></div>

  <div class="vignette" aria-hidden="true"></div>

  <!-- Foreground -->
  <div class="wrap">
    <header>
      <div></div>
      <h1>⏳ Guess whos back</h1>
      <div class="controls">
        <button class="btn" id="shuffleBtn" title="Rebuild wall">Shuffle</button>
        <button class="btn" id="fsBtn" title="Fullscreen">Fullscreen</button>
      </div>
    </header>

    <main class="timer-card" id="timerCard" aria-live="polite" aria-label="Countdown">
      <div class="label">Countdown to November 1, 2025 — 19:40</div>
      <div class="timer">
        <div class="tbox"><div class="num" id="days">00</div><div class="lab">Days</div></div>
        <div class="tbox"><div class="num" id="hours">00</div><div class="lab">Hours</div></div>
        <div class="tbox"><div class="num" id="mins">00</div><div class="lab">Minutes</div></div>
        <div class="tbox"><div class="num" id="secs">00</div><div class="lab">Seconds</div></div>
      </div>
    </main>

    <footer></footer>
  </div>

  <!-- One-time Intro Overlay -->
  <div class="intro" id="intro" aria-hidden="true">
    <div class="intro-tiles" id="introTiles"></div>
    <div class="intro-head">
      <div class="intro-title">⏳ Guess whos back</div>
      <div class="intro-sub">Countdown to November 1, 2025 — 19:40</div>
    </div>
    <button class="intro-skip" id="introSkip" aria-label="Skip intro">Skip</button>
  </div>

  <script>
    // ===== CONFIG =====
    const DEFAULT_TARGET = new Date("2025-11-01T19:40:00+03:00");

    // Adaptive rotation: a bit slower and smaller batches on touch devices
    const isTouch = (navigator.maxTouchPoints || 'ontouchstart' in window);
    let ROTATE_MS = isTouch ? 7000 : 6000;     // tick rate
    function rotateBatchSize(){                // ~6–10% of visible tiles per tick
      return Math.max(1, Math.round(tiles.length * (isTouch ? 0.06 : 0.10)));
    }
    const PAUSE_ON_HOVER = true;               // don't swap a tile if hovered (desktop)

    const IMAGES = [
      { src: "images/02cd0734-aeed-481c-8aa5-f702d5d0d8f8.jpg", caption: "02cd0734-aeed-481c-8aa5-f702d5d0d8f8" },
      { src: "images/093fa11a-09d5-46c5-992f-a8214f33dd24.jpg", caption: "093fa11a-09d5-46c5-992f-a8214f33dd24" },
      { src: "images/23486ee9-c9ff-49f4-91c2-965f7bb613fb.jpg", caption: "23486ee9-c9ff-49f4-91c2-965f7bb613fb" },
      { src: "images/2a82b7e3-aaf8-4975-8db9-6adfb3aaa17f (1).jpg", caption: "2a82b7e3-aaf8-4975-8db9-6adfb3aaa17f (1)" },
      { src: "images/2a82b7e3-aaf8-4975-8db9-6adfb3aaa17f.jpg", caption: "2a82b7e3-aaf8-4975-8db9-6adfb3aaa17f" },
      { src: "images/2b7c2966-2b5e-4454-9d10-98555d284151.jpg", caption: "2b7c2966-2b5e-4454-9d10-98555d284151" },
      { src: "images/3adb046f-8fa9-46ef-82c6-3b62ea548f98.jpg", caption: "3adb046f-8fa9-46ef-82c6-3b62ea548f98" },
      { src: "images/3d3bae9c-d0cc-4276-a533-358190ed9f0f.jpg", caption: "3d3bae9c-d0cc-4276-a533-358190ed9f0f" },
      { src: "images/48f209d0-fc9a-4a18-b79b-50e6f5472d15.jpg", caption: "48f209d0-fc9a-4a18-b79b-50e6f5472d15" },
      { src: "images/4de57708-9c10-488f-b3d4-3bd028b0c419.jpg", caption: "4de57708-9c10-488f-b3d4-3bd028b0c419" },
      { src: "images/55ad0428-7aa0-456b-a266-46551bebc32e.jpg", caption: "55ad0428-7aa0-456b-a266-46551bebc32e" },
      { src: "images/5c83032d-316a-4f77-abd7-83a9e3caaf41.jpg", caption: "5c83032d-316a-4f77-abd7-83a9e3caaf41" },
      { src: "images/63750321-dbea-4535-8316-77f68fdacd70.jpg", caption: "63750321-dbea-4535-8316-77f68fdacd70" },
      { src: "images/a311202a-09f7-4867-990c-e4fb0f1ed3f3.jpg", caption: "a311202a-09f7-4867-990c-e4fb0f1ed3f3" },
      { src: "images/be6233fa-b8e3-4e27-a072-8e991c0bbb9d.jpg", caption: "be6233fa-b8e3-4e27-a072-8e991c0bbb9d" },
      { src: "images/ccef7cb9-797a-4d16-92ad-cfb6f80b8936.jpg", caption: "ccef7cb9-797a-4d16-92ad-cfb6f80b8936" },
      { src: "images/d14e1016-ae17-44c0-a4ca-db88129045ae.jpg", caption: "d14e1016-ae17-44c0-a4ca-db88129045ae" },
      { src: "images/IMG_20161229_204822.jpg", caption: "IMG_20161229_204822" },
      { src: "images/IMG_20170709_123029.jpg", caption: "IMG_20170709_123029" },
      { src: "images/IMG_20180818_215728.jpg", caption: "IMG_20180818_215728" },
      { src: "images/IMG_20190714_222629.jpg", caption: "IMG_20190714_222629" },
      { src: "images/IMG_20200517_230350.jpg", caption: "IMG_20200517_230350" },
      { src: "images/IMG_20200517_230712.jpg", caption: "IMG_20200517_230712" },
      { src: "images/IMG_20200911_195128.jpg", caption: "IMG_20200911_195128" },
      { src: "images/IMG_20200920_235009.jpg", caption: "IMG_20200920_235009" },
      { src: "images/IMG_20211103_135906.jpg", caption: "IMG_20211103_135906" },
      { src: "images/IMG_20211229_140745.jpg", caption: "IMG_20211229_140745" },
      { src: "images/IMG_20220304_185250.jpg", caption: "IMG_20220304_185250" },
      { src: "images/IMG_20220306_014832.jpg", caption: "IMG_20220306_014832" },
      { src: "images/IMG_20220918_112717.jpg", caption: "IMG_20220918_112717" },
      { src: "images/IMG_20231224_192027.jpg", caption: "IMG_20231224_192027" },
      { src: "images/IMG_20231224_192029.jpg", caption: "IMG_20231224_192029" },
      { src: "images/IMG_20231224_193639.jpg", caption: "IMG_20231224_193639" },
      { src: "images/IMG_20240801_150855.jpg", caption: "IMG_20240801_150855" },
      { src: "images/IMG_20250518_014704004_HDR.jpg", caption: "IMG_20250518_014704004_HDR" },
      { src: "images/IMG_20250712_170059692_HDR.jpg", caption: "IMG_20250712_170059692_HDR" },
      { src: "images/IMG-03f3f1c4e0267361ac36fe54f693e5c8-V.jpg", caption: "IMG-03f3f1c4e0267361ac36fe54f693e5c8-V" },
      { src: "images/IMG-04980a02c9db1f32bc1177f6a7ec2c5a-V.jpg", caption: "IMG-04980a02c9db1f32bc1177f6a7ec2c5a-V" },
      { src: "images/IMG-2329c943ad6d3f766f94eab89b50b11a-V.jpg", caption: "IMG-2329c943ad6d3f766f94eab89b50b11a-V" },
      { src: "images/IMG-2732836ad0913300a7cec997420d2062-V.jpg", caption: "IMG-2732836ad0913300a7cec997420d2062-V" },
      { src: "images/IMG-3f1e084ec09dff8a9e2450243f9488f5-V.jpg", caption: "IMG-3f1e084ec09dff8a9e2450243f9488f5-V" },
      { src: "images/IMG-46066c2c94eb783eccf4a0eeef4a3c5b-V.jpg", caption: "IMG-46066c2c94eb783eccf4a0eeef4a3c5b-V" },
      { src: "images/IMG-594f5025cd9fd8a0d2291808cdca3068-V.jpg", caption: "IMG-594f5025cd9fd8a0d2291808cdca3068-V" },
      { src: "images/IMG-66cef66854a2d403e87cdc48db4d0d00-V.jpg", caption: "IMG-66cef66854a2d403e87cdc48db4d0d00-V" },
      { src: "images/IMG-68efab05e947fd0394c6655f4dcb7089-V.jpg", caption: "IMG-68efab05e947fd0394c6655f4dcb7089-V" },
      { src: "images/IMG-97887e1ab4543b9c3c57f8fab290f442-V.jpg", caption: "IMG-97887e1ab4543b9c3c57f8fab290f442-V" },
      { src: "images/IMG-a3a413fb089a5ec393fc1b7cf2cbf1a5-V.jpg", caption: "IMG-a3a413fb089a5ec393fc1b7cf2cbf1a5-V" },
      { src: "images/IMG-b08581958d11f8f18618c0146ce7a3d1-V.jpg", caption: "IMG-b08581958d11f8f18618c0146ce7a3d1-V" },
      { src: "images/IMG-b84b7af0e004ce5547a2a84ff4549fbd-V.jpg", caption: "IMG-b84b7af0e004ce5547a2a84ff4549fbd-V" },
      { src: "images/IMG-c0441107acf56fda82d7fffce4414337-V.jpg", caption: "IMG-c0441107acf56fda82d7fffce4414337-V" },
      { src: "images/IMG-cfa98d31dd2114be583b90a8c49fbb79-V.jpg", caption: "IMG-cfa98d31dd2114be583b90a8c49fbb79-V" },
      { src: "images/IMG-e4486668d6c31da4efae332d23c0287b-V.jpg", caption: "IMG-e4486668d6c31da4efae332d23c0287b-V" },
      { src: "images/IMG-e93e24ed45c18b1516c3e7ed34c7fead-V.jpg", caption: "IMG-e93e24ed45c18b1516c3e7ed34c7fead-V" },
      { src: "images/IMG-f0ba869f53af9d7daecc72ffe7a73d8e-V.jpg", caption: "IMG-f0ba869f53af9d7daecc72ffe7a73d8e-V" },
    ];

    // ===== Countdown =====
    const pad = n => String(n).padStart(2,"0");
    let cdInterval=null;
    function startCountdown(targetDate){
      if(cdInterval) clearInterval(cdInterval);
      function tick(){
        const now=new Date(); let diff=Math.max(0,targetDate-now);
        const d=Math.floor(diff/86400000); diff-=d*86400000;
        const h=Math.floor(diff/3600000);  diff-=h*3600000;
        const m=Math.floor(diff/60000);    diff-=m*60000;
        const s=Math.floor(diff/1000);
        days.textContent=pad(d); hours.textContent=pad(h); mins.textContent=pad(m); secs.textContent=pad(s);
      }
      const days=document.getElementById("days"), hours=document.getElementById("hours"),
            mins=document.getElementById("mins"), secs=document.getElementById("secs");
      tick(); cdInterval=setInterval(tick,1000);
    }
    startCountdown(DEFAULT_TARGET);

    // ===== Elements
    const wall=document.getElementById("wall");
    const timerCard=document.getElementById("timerCard");
    const shuffleBtn=document.getElementById("shuffleBtn");
    const fsBtn=document.getElementById("fsBtn");
    const bg1=document.getElementById("bg1");
    const bg2=document.getElementById("bg2");

    // ===== Intro elements & logic
    const intro = document.getElementById('intro');
    const introTiles = document.getElementById('introTiles');
    const introSkip = document.getElementById('introSkip');
    const INTRO_KEY = 'intro_seen_v1';
    const INTRO_LEN = 2400; // ms until auto-hide

    function spawnIntroTiles(){
      // Create 24 floating shards with staggered timings
      const N = 24;
      const W = innerWidth, H = innerHeight;
      for(let i=0;i<N;i++){
        const d = document.createElement('div');
        d.className = 'intro-tile';
        const x = Math.random()*W, y = Math.random()*H;
        d.style.left = (x - W*0.1) + 'px';
        d.style.top  = (y - H*0.1) + 'px';
        d.style.setProperty('--delay', (Math.random()*400) + 'ms');
        d.style.setProperty('--dur', (1600 + Math.random()*900) + 'ms');
        d.style.setProperty('--rot', (Math.random()*16 - 8) + 'deg');
        introTiles.appendChild(d);
      }
    }
    function hideIntro(){
      intro.classList.add('hide');
      setTimeout(()=>{ intro.remove(); }, 650);
    }
    function maybePlayIntro(){
      const reduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const seen = localStorage.getItem(INTRO_KEY) === '1';
      if(seen || reduced){ hideIntro(); return; }

      spawnIntroTiles();
      const t = setTimeout(()=>{ hideIntro(); }, INTRO_LEN);
      introSkip.addEventListener('click', ()=>{ clearTimeout(t); hideIntro(); }, { once:true });
      localStorage.setItem(INTRO_KEY,'1');
    }
    // Start intro after first paint
    window.addEventListener('load', maybePlayIntro);

    // Preload (optional; browser will cache as they load during rotation)
    IMAGES.forEach(i=>{const im=new Image(); im.src=i.src;});

    // --- Blue-noise cell picking (even spread)
    function pickEvenlySpacedCells(freeCells, desired, cols, rows){
      if(!freeCells.length||desired<=0) return [];
      const cx=(cols-1)/2, cy=(rows-1)/2;
      let seed=freeCells[0], best=-1;
      for(const c of freeCells){ const dx=c.col-cx, dy=c.row-cy, s=dx*dx+dy*dy; if(s>best){best=s; seed=c;} }
      const selected=[seed];
      while(selected.length<desired && selected.length<freeCells.length){
        let bestCell=null, bestDist=-1;
        for(const c of freeCells){
          if(selected.some(s=>s.col===c.col && s.row===c.row)) continue;
          let minD2=Infinity;
          for(const s of selected){ const dx=c.col-s.col, dy=c.row-s.row, d2=dx*dx+dy*dy; if(d2<minD2) minD2=d2; }
          if(minD2>bestDist){ bestDist=minD2; bestCell=c; }
        }
        if(!bestCell) break; selected.push(bestCell);
      }
      return selected;
    }
    function shuffleInPlace(a){ for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

    // ===== Photo Wall (with rotation) =====
    let tiles = [];                    // [{ el, imgEl, imgIndex }]
    let visibleSet = new Set();        // image indexes currently on screen
    let pool = [];                     // image indexes available to rotate in
    let rotateTimer = null;
    const lastSwapAt = new Map();      // tile -> timestamp to avoid rapid re-swap

    function computeFreeCells(cols, rows, gap, cellW, cellH, guard){
      const r=timerCard.getBoundingClientRect();
      const startCol=Math.max(0,Math.floor((r.left-gap)/(cellW+gap))-guard);
      const endCol=Math.min(cols-1,Math.floor((r.right-gap)/(cellW+gap))+guard);
      const startRow=Math.max(0,Math.floor((r.top-gap)/(cellH+gap))-guard);
      const endRow=Math.min(rows-1,Math.floor((r.bottom-gap)/(cellH+gap))+guard);
      const free=[];
      for(let row=0; row<rows; row++){
        for(let col=0; col<cols; col++){
          const inside=(col>=startCol && col<=endCol && row>=startRow && row<=endRow);
          if(!inside) free.push({row,col});
        }
      }
      return free;
    }

    function stopWallRotation(){
      if(rotateTimer){ clearInterval(rotateTimer); rotateTimer=null; }
    }

    function startWallRotation(){
      stopWallRotation();
      if(pool.length === 0) return; // nothing to rotate in
      rotateTimer = setInterval(rotateSomeTiles, ROTATE_MS);
    }

    function rotateSomeTiles(){
      if(pool.length === 0 || tiles.length === 0) return;

      const now = performance.now();
      const candidates = tiles
        .map((t, i) => ({t, i}))
        .filter(({t})=>{
          if(PAUSE_ON_HOVER && t.el.matches(':hover')) return false;
          const last = lastSwapAt.get(t.el) || 0;
          return (now - last) > ROTATE_MS * 1.2;
        });

      if(candidates.length === 0) return;

      shuffleInPlace(candidates);
      const swaps = Math.min(rotateBatchSize(), candidates.length, pool.length);
      for(let k=0; k<swaps; k++){
        const {t} = candidates[k];
        let nextIdx = pool.shift();
        if(nextIdx == null) break;

        if(visibleSet.has(nextIdx)){
          let found = -1;
          for(let j=0;j<pool.length;j++){
            if(!visibleSet.has(pool[j])){ found = j; break; }
          }
          if(found >= 0){
            pool.push(nextIdx);
            nextIdx = pool.splice(found, 1)[0];
          }
        }

        if (Number.isInteger(t.imgIndex)) {
          visibleSet.delete(t.imgIndex);
          pool.push(t.imgIndex);
        }

        // Preload first, then cross-fade (no black gap)
        const meta = IMAGES[nextIdx];
        const pre = new Image();
        pre.decoding = "async";
        pre.src = meta.src;

        pre.onload = () => {
          const el = t.imgEl;
          el.style.transition = "opacity .35s ease";
          el.style.opacity = 0;
          requestAnimationFrame(() => {
            el.src = pre.src;
            el.alt = meta.caption || "Photo";
            el.style.opacity = .96;
          });
        };

        pre.onerror = () => {
          // put it back if it failed to load
          pool.push(nextIdx);
        };

        t.imgIndex = nextIdx;
        visibleSet.add(nextIdx);
        lastSwapAt.set(t.el, now);
      }
    }

    function buildWall(){
      const W=innerWidth, H=innerHeight, cs=getComputedStyle(document.documentElement);
      const gap=parseFloat(cs.getPropertyValue("--tile-gap"))||6;
      const target=parseFloat(cs.getPropertyValue("--tile-target"))||150;
      const coverageBase=Math.max(0,Math.min(1,parseFloat(cs.getPropertyValue("--coverage"))||0.6));
      const guardBase=parseInt(cs.getPropertyValue("--guard-cells"))||0;

      const cols=Math.max(2,Math.floor((W-gap)/(target+gap)));
      const rows=Math.max(2,Math.floor((H-gap)/(target+gap)));
      const cellW=(W-gap*(cols+1))/cols, cellH=(H-gap*(rows+1))/rows;
      wall.style.gridTemplateColumns=`repeat(${cols},1fr)`;

      let guard=guardBase;
      let free=computeFreeCells(cols,rows,gap,cellW,cellH,guard);
      if(free.length===0){
        guard=0;
        free=computeFreeCells(cols,rows,gap,cellW,cellH,guard);
        if(free.length===0){ for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) free.push({row:r,col:c}); }
      }

      const total=rows*cols;
      const relaxed = (guard!==guardBase);
      const coverage = relaxed ? Math.min(coverageBase, 0.40) : coverageBase;

      const desired = Math.min(free.length, Math.max(1, Math.round(total * coverage)));
      // At (almost) full coverage, just use every free cell to avoid holes.
      const cells = (desired >= free.length - 1)
        ? free
        : pickEvenlySpacedCells(free, desired, cols, rows);

      const allIdx = [...IMAGES.keys()];
      shuffleInPlace(allIdx);

      visibleSet.clear();
      tiles = [];
      wall.innerHTML="";
      lastSwapAt.clear();

      const initial = allIdx.slice(0, Math.min(desired, allIdx.length));
      pool = allIdx.slice(initial.length);
      while(initial.length < desired){ initial.push(...allIdx); }

      for(let i=0;i<cells.length;i++){
        const {row,col}=cells[i];
        const idx = initial[i % initial.length];
        const t=document.createElement("div"); t.className="tile";
        t.style.gridColumn=(col+1); t.style.gridRow=(row+1);
        const img=document.createElement("img");
        img.src=IMAGES[idx].src; img.alt=IMAGES[idx].caption||`Photo ${i+1}`;
        img.loading="eager";
        img.decoding="async";
        t.appendChild(img); wall.appendChild(t);
        tiles.push({ el: t, imgEl: img, imgIndex: idx });
        visibleSet.add(idx);
      }

      pool = pool.filter(id => !visibleSet.has(id));
      startWallRotation();
    }

    // Rebuild wall on resize / shuffle
    let resizeT; function rebuildWallSoon(){ clearTimeout(resizeT); resizeT=setTimeout(buildWall,120); }
    addEventListener("load", buildWall);
    addEventListener("resize", ()=>{ stopWallRotation(); rebuildWallSoon(); });
    shuffleBtn.addEventListener("click", ()=>{ stopWallRotation(); buildWall(); });

    // ===== Fullscreen slideshow (FIT, random order each time; IMAGES immutable) =====
    let slideIdx=0, onFirst=true, autoTimer=null; const AUTO_MS=6000;
    let fsOrder = [];   // shuffled array of indexes into IMAGES

    function setBG(div, i){
      if (!fsOrder.length) return;
      const id = fsOrder[(i + fsOrder.length) % fsOrder.length];
      const it = IMAGES[id];
      div.style.backgroundImage=`url('${it.src}')`;
      div.setAttribute("aria-label", it.caption||"Background photo");
    }
    function showNext(){
      const next=(slideIdx+1)%fsOrder.length;
      if(onFirst){ setBG(bg2,next); bg2.style.opacity=1; bg1.style.opacity=0; }
      else       { setBG(bg1,next); bg1.style.opacity=1; bg2.style.opacity=0; }
      onFirst=!onFirst; slideIdx=next;
    }
    function startSlideshow(){
      if(!IMAGES.length) return;
      fsOrder = IMAGES.map((_, i) => i);
      shuffleInPlace(fsOrder);      // shuffle the indexes, not IMAGES
      slideIdx = 0; onFirst = true;
      setBG(bg1,0);
      if(autoTimer) clearInterval(autoTimer);
      autoTimer=setInterval(showNext,AUTO_MS);
    }
    function restartAuto(){ if(autoTimer){ clearInterval(autoTimer); autoTimer=setInterval(showNext,AUTO_MS);} }
    addEventListener("keydown", e=>{
      if(!document.fullscreenElement) return;
      if(e.key==="ArrowRight"){ showNext(); restartAuto(); }
      if(e.key==="ArrowLeft"){
        const prev=(slideIdx-1+fsOrder.length)%fsOrder.length;
        if(onFirst){ setBG(bg2,prev); bg2.style.opacity=1; bg1.style.opacity=0; }
        else       { setBG(bg1,prev); bg1.style.opacity=1; bg2.style.opacity=0; }
        onFirst=!onFirst; slideIdx=prev; restartAuto();
      }
    });

    // Fullscreen toggle
    fsBtn.addEventListener("click", ()=>{
      if(!document.fullscreenElement) document.documentElement.requestFullscreen?.();
      else document.exitFullscreen?.();
    });
    document.addEventListener("fullscreenchange", ()=>{
      const fs=!!document.fullscreenElement;
      document.body.classList.toggle("fs-active", fs);
      if(fs){
        stopWallRotation();
        startSlideshow();
      } else {
        if(autoTimer) clearInterval(autoTimer);
        setTimeout(buildWall, 30);
      }
    });
  </script>
  
  <script>
  window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
  </script>
  <script defer src="/_vercel/insights/script.js"></script>

</body>
</html>
